<html lang="en">
<head>
    <base href="." />
    <title>Smart Home Assistant Dashboard</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@400;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&display=swap');

/* Update the root theme (dark) */
:root {
  --bg-color: #121212;
  --text-color: #ffffff;
  --widget-bg: rgba(30, 30, 30, var(--widget-opacity, 0.9));
  --widget-border: 1px solid rgba(255, 255, 255, 0.15);
  --accent-color: #00b4d8;
  --widget-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
  --text-secondary: rgba(255, 255, 255, 0.7);
  --font-family: 'Inter', sans-serif;
  --base-font-size: 16px;
}

/* Update the cats theme */
[data-theme="cats"] {
  --bg-color: #3e1d5a;  /* Muted purple background */
  --text-color: #fdfcff; /* Off-white text */
  --widget-bg: rgba(62, 29, 90, var(--widget-opacity, 0.9)); /* Lighter purple widgets */
  --widget-border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
  --accent-color: #ff9a8d; /* Soft coral accent */
  --widget-shadow: 0 4px 12px rgba(255, 154, 141, 0.2);
  --text-secondary: rgba(253, 252, 255, 0.7);
  --font-family: 'Quicksand', sans-serif;
}

/* Update the space theme */
[data-theme="space"] {
  --bg-color: #1a002b; /* Deep space background */
  --text-color: #e0e0e0; /* Light gray text */
  --widget-bg: rgba(26, 0, 43, var(--widget-opacity, 0.9)); /* Dark violet widgets */
  --widget-border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
  --accent-color: #7f5af0; /* Vibrant purple accent */
  --widget-shadow: 0 4px 12px rgba(127, 90, 240, 0.2);
  --text-secondary: rgba(224, 224, 224, 0.7);
  --font-family: 'Space Grotesk', sans-serif;
}

body {
  margin: 0;
  padding: 0;
  font-family: var(--font-family);
  background: var(--bg-color);
  color: var(--text-color);
  overflow: hidden;
  font-size: var(--base-font-size);
}

.dashboard {
  width: 100vw;
  height: 100vh;
  position: relative;
  padding: 10px;
  box-sizing: border-box;
}

.camera-grid {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 5px;
}

.camera-feed {
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 1;
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-color);
  font-size: 1.2em;
  text-align: center;
  position: relative;
  transform: translateZ(0);
  will-change: transform;
}

.camera-feed::before {
  content: attr(data-placeholder);
  position: absolute;
  padding: 20px;
  z-index: 1;
}

.camera-feed[autoplay] {
  opacity: 1;
  background: black;
}

.widget,
.widget * {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  cursor: default;
}

.widget {
  position: absolute;
  width: 250px;
  height: 150px;
  min-width: 100px;
  min-height: 100px;
  background: var(--widget-bg);
  border: var(--widget-border);
  border-radius: 10px;
  padding: 15px;
  box-shadow: var(--widget-shadow);
  backdrop-filter: blur(var(--blur-amount));
  cursor: move;
  transition: transform 0.2s;
  overflow: hidden;
  max-width: calc(100vw - 40px);
  max-height: calc(100vh - 40px);
  box-sizing: border-box;
  font-size: var(--base-font-size);
}

.widget:hover {
  transform: scale(1.02);
}

.widget-content {
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.clock {
  font-size: 3em;
  font-weight: bold;
  text-align: center;
}

.date {
  font-size: 1.2em;
  margin-top: 10px;
  color: var(--text-secondary);
}

.weather-widget {
  width: 100%;
  height: 100%;
  overflow-y: auto;
}

.weather-info {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  width: 100%;
  box-sizing: border-box;
  font-size: 0.8em;
}

.weather-icon {
  font-size: min(2em, 4vw);
  line-height: 1;
  margin: 5px 0;
}

.temperature {
  font-size: min(1.8em, 3.6vw);
  font-weight: bold;
  line-height: 1;
}

.weather-details {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2px;
  width: 100%;
  font-size: 0.75em;
  margin: 2px 0;
}

.weather-details > div,
.forecast-items > div {
  background: rgba(255, 255, 255, 0.1);
  padding: 2px;
  border-radius: 4px;
  text-align: center;
  color: var(--text-secondary);
  white-space: nowrap;
}

.forecast {
  width: 100%;
}

.forecast-title {
  font-size: 0.8em;
  opacity: 0.8;
  margin-bottom: 2px;
  color: var(--text-secondary);
}

.forecast-items {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
  gap: 2px;
  width: 100%;
}

#cityInput {
  width: calc(100% - 16px);
  padding: 4px;
  margin: 0;
  border: none;
  border-radius: 4px;
  background: rgba(255, 255, 255, 0.1);
  color: var(--text-color);
}

.city-suggestions {
  position: absolute;
  top: calc(30px);
  left: 15px;
  right: 15px;
  max-height: 150px;
}

.weather-widget input {
  width: 100%;
  padding: 4px;
  margin-bottom: 5px;
  border: none;
  border-radius: 5px;
  background: rgba(255, 255, 255, 0.1);
  color: var(--text-color);
}

.sensor-name {
  font-size: 1.2em;
  margin-bottom: 5px;
  color: var(--text-secondary);
  text-align: center;
}

.settings-panel {
  position: fixed;
  right: -400px;
  top: 0;
  width: 400px;
  height: 100%;
  background: var(--widget-bg);
  padding: 20px;
  transition: right 0.3s;
  z-index: 1000;
  box-shadow: -2px 0 10px rgba(0, 0, 0, 0.2);
  overflow-y: auto;
  box-sizing: border-box;
  color: var(--text-color);
  border-left: var(--widget-border);
}

.settings-panel.active {
  right: 0;
}

.setting-item {
  margin-bottom: 15px;
  padding: 10px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 5px;
}

.setting-item label {
  display: block;
  margin-bottom: 5px;
}

.setting-item input[type="text"],
.setting-item input[type="number"],
.setting-item select {
  width: 100%;
  padding: 8px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  color: var(--text-color);
}

.settings-section {
  margin-bottom: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.apply-button,
.button {
  background: var(--accent-color);
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  margin-top: 10px;
}

.apply-button:hover,
.button:hover {
  opacity: 0.9;
}

.settings-toggle {
  position: fixed;
  right: 20px;
  top: 20px;
  z-index: 1001;
  background: var(--widget-bg);
  border: var(--widget-border);
  border-radius: 50%;
  width: 40px;
  height: 40px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  padding: 0;
  transition: transform 0.2s;
}

.settings-toggle:hover {
  transform: scale(1.1);
}

.config-buttons {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-bottom: 15px;
}

.config-button {
  background: var(--accent-color);
  color: var(--text-color);
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  transition: opacity 0.2s;
}

.config-button:hover {
  opacity: 0.9;
}

.last-update {
  font-size: 0.7em;
  color: var(--text-secondary);
  margin: 2px 0;
  text-align: center;
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  background-color: #ccc;
  border-radius: 34px;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  transition: 0.4s;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 2px;
  bottom: 2px;
  background-color: var(--text-color);
  transition: 0.4s;
  border-radius: 50%;
}

.toggle-switch input:checked + .toggle-slider {
  background-color: var(--accent-color);
}

.toggle-switch input:checked + .toggle-slider:before {
  transform: translateX(20px);
}

.widget-toggle {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

@media (max-width: 768px) {
  .settings-panel {
    width: 100%;
    right: -100%;
  }

  .settings-panel.active {
    right: 0;
  }

  .dashboard {
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: 5px;
    padding: 5px;
  }

  .widget {
    max-width: calc(100vw - 20px);
    max-height: calc(100vh - 20px);
    padding: 10px;
  }

  .clock {
    font-size: 2em;
  }
}

[data-theme="cats"] .camera-feed {
  border: 2px solid #ff9a8d; /* Match the accent color */
  background: rgba(0, 0, 0, 0.6);
}

[data-theme="space"] .camera-feed {
  border: 2px solid #7f5af0; /* Match the accent color */
  background: rgba(0, 0, 0, 0.7);
}

.widget input,
.widget select {
  cursor: text;
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
}
    </style>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/streamedian@latest/dist/streamedian.min.js"></script>

    <script>
function loadConfig(configId) {
  window.location.href = `index.html?config=${configId}`;
}

function dragMoveListener(event) {
  const target = event.target;
  const left = (parseFloat(target.style.left) || 0) + event.dx;
  const top = (parseFloat(target.style.top) || 0) + event.dy;

  target.style.left = `${left}px`;
  target.style.top = `${top}px`;
}

function getWeatherIcon(code) {
  const icons = {
    0: '☀️',
    1: '🌤️',
    2: '⛅',
    3: '☁️',
    45: '🌫️',
    48: '🌫️',
    51: '🌧️',
    53: '🌧️',
    55: '🌧️',
    61: '🌧️',
    63: '🌧️',
    65: '🌧️',
    71: '🌨️',
    73: '🌨️',
    75: '🌨️',
    77: '🌨️',
    80: '🌧️',
    81: '🌧️',
    82: '🌧️',
    85: '🌨️',
    86: '🌨️',
    95: '⛈️',
    96: '⛈️',
    99: '⛈️'
  };
  return icons[code] || '❓';
}

async function updateWeather(lat, lon, cityName) {
  try {
    const response = await fetch(
      `https://api.open-meteo.com/v1/forecast?` +
      `latitude=${lat}&longitude=${lon}` +
      `&current_weather=true` +
      `&daily=weathercode,temperature_2m_max,temperature_2m_min` +
      `&hourly=temperature_2m,relativehumidity_2m,windspeed_10m,windgusts_10m,pressure_msl` +
      `&timezone=auto`
    );

    const data = await response.json();
    const current = data.current_weather;
    const currentHour = new Date().getHours();
    const weatherInfo = document.querySelector('.weather-info');

    let forecastDays = '';
    for (let i = 1; i <= 4; i++) {
      const date = new Date();
      date.setDate(date.getDate() + i);
      forecastDays += `
        <div class="forecast-item">
          <div>${date.toLocaleDateString('en-GB', {weekday: 'short'})}</div>
          <div>${getWeatherIcon(data.daily.weathercode[i])}</div>
          <div>${Math.round(data.daily.temperature_2m_max[i])}°</div>
          <div>${Math.round(data.daily.temperature_2m_min[i])}°</div>
        </div>
      `;
    }

    weatherInfo.innerHTML = `
      <div class="weather-icon">${getWeatherIcon(current.weathercode)}</div>
      <div class="temperature">${Math.round(current.temperature)}°C</div>
      <div class="last-update">Last updated: ${new Date().toLocaleTimeString('en-GB', { hour12: false })}</div>
      <div class="weather-details">
        <div class="wind">Wind: ${Math.round(current.windspeed)} km/h</div>
        <div class="gusts">Gusts: ${Math.round(data.hourly.windgusts_10m[currentHour])} km/h</div>
        <div class="pressure">Pressure: ${Math.round(data.hourly.pressure_msl[currentHour])} hPa</div>
        <div class="humidity">Humidity: ${data.hourly.relativehumidity_2m[currentHour]}%</div>
      </div>
      <div class="forecast">
        <div class="forecast-title">Next Days:</div>
        <div class="forecast-items">
          ${forecastDays}
        </div>
      </div>
    `;
  } catch (error) {
    console.error('Error updating weather:', error);
  }
}

class ConfigManager {
  constructor() {
    this.config = {
      theme: 'dark',
      cameras: [
        { url: '', name: 'Camera 1' }
      ],
      widgets: {
        clock: { enabled: true, position: { x: 20, y: 20 }, size: { w: 250, h: 150 } },
        weather: { enabled: true, position: { x: window.innerWidth - 270, y: 20 }, size: { w: 250, h: 150 } },
        temp1: { enabled: true, position: { x: 20, y: window.innerHeight - 170 }, size: { w: 250, h: 150 } },
        temp2: { enabled: true, position: { x: window.innerWidth - 270, y: window.innerHeight - 170 }, size: { w: 250, h: 150 } }
      },
      sensors: {
        temp1: { url: '', refreshInterval: 30, name: 'Sensor 1' },
        temp2: { url: '', refreshInterval: 30, name: 'Sensor 2' }
      },
      appearance: {
        opacity: 0.9,
        blur: 10,
        fontSize: 16
      },
      cameraGrid: {
        columns: 1,
        rows: 1,
        numCameras: 1
      }
    };

    this._sensorPolling = {};
    this._latestWeatherLat = null;
    this._latestWeatherLon = null;

    this.loadConfig();
    this.setupWeatherWidget();
    this.setupEventListeners();

    this.setupCameraGrid(1);

    window.addEventListener('resize', () => {
      this.applyWidgetPositions();
    });

    setInterval(async () => {
      const city = this.config.widgets.weather.weatherData?.city || '';
      const lat = this._latestWeatherLat || this.config.widgets.weather.weatherData?.lat;
      const lon = this._latestWeatherLon || this.config.widgets.weather.weatherData?.lon;
      if (lat && lon) {
        await updateWeather(lat, lon, city);
      }
    }, 15 * 60 * 1000); // Update every 15 minutes
  }

  _throttle(func, limit) {
    let inThrottle;
    return function(...args) {
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    }
  }

  applyConfig() {
    document.body.setAttribute('data-theme', this.config.theme);

    const themeSelect = document.getElementById('themeSelect');
    if (themeSelect) {
      themeSelect.value = this.config.theme;
    }

    if (this.config.appearance) {
      this.updateAppearance();
    }

    if (this.config.widgets) {
      Object.entries(this.config.widgets).forEach(([widgetId, widget]) => {
        const widgetElement = document.getElementById(widgetId);
        if (widgetElement && widget.position && widget.size) {
          widgetElement.style.width = `${widget.size.w}px`;
          widgetElement.style.height = `${widget.size.h}px`;
          widgetElement.style.left = `${widget.position.x}px`;
          widgetElement.style.top = `${widget.position.y}px`;

          // Adjust font size based on widget size
          const baseWidth = 250;
          const baseHeight = 150;
          const baseFontSize = 16;

          const scaleWidth = widget.size.w / baseWidth;
          const scaleHeight = widget.size.h / baseHeight;
          const scale = Math.min(scaleWidth, scaleHeight);
          const newFontSize = baseFontSize * scale;

          widgetElement.style.fontSize = `${newFontSize}px`;
        }

        if (widget.hasOwnProperty('enabled')) {
          this.updateWidgetVisibility(widgetId, widget.enabled);
        }

        if (widgetId === 'weather') {
          const cityInput = widgetElement.querySelector('#cityInput');
          const weatherInfo = widgetElement.querySelector('.weather-info');
          if (widget.weatherData) {
            cityInput.value = widget.weatherData.city || '';
            if (widget.weatherData.lat && widget.weatherData.lon) {
              this._latestWeatherLat = widget.weatherData.lat;
              this._latestWeatherLon = widget.weatherData.lon;
              updateWeather(widget.weatherData.lat, widget.weatherData.lon, cityInput.value);
            }
          }
        }
      });
    }

    // Apply sensor settings to inputs
    const sensor1UrlInput = document.getElementById('temp1Url');
    const sensor1NameInput = document.getElementById('temp1Name');
    const sensor1IntervalInput = document.getElementById('temp1Interval');
    const sensor2UrlInput = document.getElementById('temp2Url');
    const sensor2NameInput = document.getElementById('temp2Name');
    const sensor2IntervalInput = document.getElementById('temp2Interval');

    if (sensor1UrlInput && this.config.sensors.temp1) {
      sensor1UrlInput.value = this.config.sensors.temp1.url || '';
      sensor1NameInput.value = this.config.sensors.temp1.name || '';
      sensor1IntervalInput.value = this.config.sensors.temp1.refreshInterval || 30;
    }

    if (sensor2UrlInput && this.config.sensors.temp2) {
      sensor2UrlInput.value = this.config.sensors.temp2.url || '';
      sensor2NameInput.value = this.config.sensors.temp2.name || '';
      sensor2IntervalInput.value = this.config.sensors.temp2.refreshInterval || 30;
    }

    // Start sensor polling
    ['temp1', 'temp2'].forEach(sensorId => {
      const widget = this.config.widgets[sensorId];
      if (widget && widget.enabled) {
        this.startSensorPolling(sensorId);
      }
    });

    this.setupCameraGrid(this.config.cameraGrid.numCameras || 1);
  }

  exportConfig() {
    const widgets = document.querySelectorAll('.widget');
    widgets.forEach(widget => {
      const id = widget.id;
      const x = parseFloat(widget.style.left) || 0;
      const y = parseFloat(widget.style.top) || 0;
      const width = widget.offsetWidth;
      const height = widget.offsetHeight;

      if (this.config.widgets[id]) {
        this.config.widgets[id].position = { x, y };
        this.config.widgets[id].size = { w: width, h: height };

        if (id === 'weather') {
          const cityInput = widget.querySelector('#cityInput');
          this.config.widgets[id].weatherData = {
            city: cityInput.value,
            lat: this._latestWeatherLat,
            lon: this._latestWeatherLon
          };
        }
      }
    });

    const exportConfig = {
      theme: this.config.theme,
      cameras: this.config.cameras,
      widgets: this.config.widgets,
      sensors: this.config.sensors,
      appearance: this.config.appearance,
      cameraGrid: this.config.cameraGrid
    };

    const configBlob = new Blob(
      [JSON.stringify(exportConfig, null, 2)],
      { type: 'application/json' }
    );

    const downloadLink = document.createElement('a');
    downloadLink.href = URL.createObjectURL(configBlob);
    downloadLink.download = 'dashboard-config.json';

    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);

    URL.revokeObjectURL(downloadLink.href);
  }

  resetConfig() {
    this.config = {
      theme: 'dark',
      cameras: [
        { url: '', name: 'Camera 1' }
      ],
      widgets: {
        clock: { enabled: true, position: { x: 20, y: 20 }, size: { w: 250, h: 150 } },
        weather: { enabled: true, position: { x: window.innerWidth - 270, y: 20 }, size: { w: 250, h: 150 } },
        temp1: { enabled: true, position: { x: 20, y: window.innerHeight - 170 }, size: { w: 250, h: 150 } },
        temp2: { enabled: true, position: { x: window.innerWidth - 270, y: window.innerHeight - 170 }, size: { w: 250, h: 150 } }
      },
      sensors: {
        temp1: { url: '', refreshInterval: 30, name: 'Sensor 1' },
        temp2: { url: '', refreshInterval: 30, name: 'Sensor 2' }
      },
      appearance: {
        opacity: 0.9,
        blur: 10,
        fontSize: 16
      },
      cameraGrid: {
        columns: 1,
        rows: 1,
        numCameras: 1
      }
    };

    this.applyConfig();
  }

  applyWidgetPositions() {
    const widgets = this.config.widgets || {};

    Object.entries(widgets).forEach(([id, widget]) => {
      if (widget.position && widget.size) {
        const widgetElement = document.getElementById(id);
        if (widgetElement) {
          widgetElement.style.left = `${widget.position.x}px`;
          widgetElement.style.top = `${widget.position.y}px`;
          widgetElement.style.width = `${widget.size.w}px`;
          widgetElement.style.height = `${widget.size.h}px`;

          // Adjust font size based on widget size
          const baseWidth = 250;
          const baseHeight = 150;
          const baseFontSize = 16;

          const scaleWidth = widget.size.w / baseWidth;
          const scaleHeight = widget.size.h / baseHeight;
          const scale = Math.min(scaleWidth, scaleHeight);
          const newFontSize = baseFontSize * scale;

          widgetElement.style.fontSize = `${newFontSize}px`;
        }
      }
    });
  }

  async loadConfig() {
    const urlParams = new URLSearchParams(window.location.search);
    const configId = urlParams.get('config') || '1';

    try {
      const response = await fetch(`shad_default${configId}.conf`);
      if (response.ok) {
        const loadedConfig = await response.json();
        this.config = Object.assign({}, this.config, loadedConfig);
      }
    } catch (error) {
      console.error('Error loading config:', error);
    }

    this.applyConfig();
  }

  setupWeatherWidget() {
    const cityInput = document.getElementById('cityInput');
    const weatherInfo = document.querySelector('.weather-info');
    let timeoutId;

    cityInput.addEventListener('input', () => {
      clearTimeout(timeoutId);
      const query = cityInput.value.trim();

      if (query.length < 3) {
        document.querySelector('.city-suggestions').innerHTML = '';
        return;
      }

      timeoutId = setTimeout(async () => {
        try {
          const response = await fetch(
            `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5&language=en&format=json`
          );
          const data = await response.json();

          if (!data.results) {
            document.querySelector('.city-suggestions').innerHTML = '<li>No results found</li>';
            return;
          }

          const suggestions = data.results.map(city => `
            <li data-lat="${city.latitude}" data-lon="${city.longitude}">
              ${city.name}, ${city.country}
            </li>
          `).join('');

          document.querySelector('.city-suggestions').innerHTML = suggestions;
        } catch (error) {
          console.error('Error searching cities:', error);
          document.querySelector('.city-suggestions').innerHTML = '<li>Error searching cities</li>';
        }
      }, 300);
    });

    document.querySelector('.city-suggestions').addEventListener('click', async (e) => {
      const li = e.target.closest('li');
      if (!li) return;

      const lat = li.dataset.lat;
      const lon = li.dataset.lon;
      cityInput.value = li.textContent.trim();
      document.querySelector('.city-suggestions').innerHTML = '';

      this._latestWeatherLat = parseFloat(lat);
      this._latestWeatherLon = parseFloat(lon);

      try {
        await updateWeather(lat, lon, cityInput.value);
      } catch (error) {
        console.error('Error fetching weather:', error);
        weatherInfo.innerHTML = '<div>Error fetching weather data</div>';
      }
    });

    document.addEventListener('click', (e) => {
      if (!cityInput.contains(e.target) && !document.querySelector('.city-suggestions').contains(e.target)) {
        document.querySelector('.city-suggestions').innerHTML = '';
      }
    });
  }

  startSensorPolling(sensorId) {
    if (!this._sensorPolling) {
      this._sensorPolling = {};
    }

    if (this._sensorPolling[sensorId]) {
      clearInterval(this._sensorPolling[sensorId]);
    }

    const sensor = this.config.sensors[sensorId];
    if (!sensor || !sensor.url) {
      console.log(`No URL configured for sensor ${sensorId}`);
      const widget = document.getElementById(sensorId);
      if (widget) {
        widget.querySelector('.temperature').textContent = '--°C';
        widget.querySelector('.humidity').textContent = '--%';
      }
      return;
    }

    const pollSensor = async () => {
      try {
        const response = await fetch(sensor.url + '?_=' + new Date().getTime(), {
          cache: 'no-cache',
          headers: {
            'Cache-Control': 'no-cache'
          }
        });
        if (!response.ok) throw new Error('Sensor request failed');
        const dataText = await response.text();

        // Expected format: 'T:21|M:45'
        const tempMatch = dataText.match(/T:([\d.]+)/);
        const humMatch = dataText.match(/M:([\d.]+)/);

        const temperature = tempMatch ? parseFloat(tempMatch[1]) : null;
        const humidity = humMatch ? parseFloat(humMatch[1]) : null;

        const widget = document.getElementById(sensorId);
        if (widget) {
          const sensorName = sensor.name || 'Sensor';
          widget.querySelector('.sensor-name').textContent = sensorName;

          widget.querySelector('.temperature').textContent =
            `${temperature !== null ? temperature.toFixed(1) : '--'}°C`;
          widget.querySelector('.humidity').textContent =
            `${humidity !== null ? humidity.toFixed(0) : '--'}%`;
        }
      } catch (error) {
        console.error(`Error polling sensor ${sensorId}:`, error);
        const widget = document.getElementById(sensorId);
        if (widget) {
          widget.querySelector('.temperature').textContent = 'Error';
          widget.querySelector('.humidity').textContent = '';
        }
      }
    };

    pollSensor();

    this._sensorPolling[sensorId] = setInterval(
      pollSensor,
      (sensor.refreshInterval || 30) * 1000
    );
  }

  updateWidgetVisibility(widgetId, visible) {
    const widget = document.getElementById(widgetId);
    if (widget) {
      widget.style.display = visible ? 'block' : 'none';

      if (this.config.widgets[widgetId]) {
        this.config.widgets[widgetId].enabled = visible;
      }

      if (widgetId === 'temp1' || widgetId === 'temp2') {
        if (visible) {
          this.startSensorPolling(widgetId);
        } else if (this._sensorPolling?.[widgetId]) {
          clearInterval(this._sensorPolling[widgetId]);
        }
      }
    }
  }

  setupCameraGrid(numCameras = 1) {
    if (this._gridUpdateTimeout) {
      clearTimeout(this._gridUpdateTimeout);
    }

    this._gridUpdateTimeout = setTimeout(() => {
      numCameras = Math.min(Math.max(numCameras, 1), 18);

      let columns =
        numCameras <= 1 ? 1 :
        numCameras <= 2 ? 2 :
        numCameras <= 4 ? 2 :
        numCameras <= 6 ? 3 :
        numCameras <= 9 ? 3 :
        numCameras <= 12 ? 4 :
        numCameras <= 16 ? 4 :
        numCameras <= 18 ? 6 : 6;

      let rows = Math.ceil(numCameras / columns);

      if (this.config.cameraGrid.columns !== columns ||
          this.config.cameraGrid.rows !== rows ||
          this.config.cameraGrid.numCameras !== numCameras) {

        this.config.cameraGrid = { columns, rows, numCameras };

        while (this.config.cameras.length < numCameras) {
          this.config.cameras.push({
            url: '',
            name: `Camera ${this.config.cameras.length + 1}`
          });
        }
      }

      requestAnimationFrame(() => {
        this.setupCameraSettings();
        this.setupCameras();
      });
    }, 100);
  }

  setupCameraSettings() {
    const cameraSettingsDiv = document.getElementById('cameraSettings');
    if (!cameraSettingsDiv) return;

    cameraSettingsDiv.innerHTML = '';

    this.config.cameras.forEach((camera, index) => {
      const cameraSettingHtml = `
        <div class="setting-item">
          <h4>Camera ${index + 1}</h4>
          <label>Stream URL:</label>
          <input type="text" class="camera-url" data-index="${index}" 
            value="${camera.url || ''}" placeholder="rtmp://example.com/stream">
          <label>Camera Name:</label>
          <input type="text" class="camera-name" data-index="${index}" 
            value="${camera.name || `Camera ${index + 1}`}" placeholder="Camera Name">
          <button class="apply-button" onclick="configManager.applyCameraSettings(${index})">Apply</button>
        </div>
      `;
      cameraSettingsDiv.insertAdjacentHTML('beforeend', cameraSettingHtml);
    });

    document.querySelectorAll('.camera-url').forEach(input => {
      input.addEventListener('change', (e) => {
        const index = parseInt(e.target.dataset.index);
        this.config.cameras[index].url = e.target.value;
      });
    });

    document.querySelectorAll('.camera-name').forEach(input => {
      input.addEventListener('change', (e) => {
        const index = parseInt(e.target.dataset.index);
        this.config.cameras[index].name = e.target.value;
      });
    });
  }

  setupCameras() {
    const cameraGrid = document.querySelector('.camera-grid');
    if (!cameraGrid) return;

    cameraGrid.innerHTML = '';

    if (!this.config.cameras || this.config.cameras.length === 0) return;

    const { columns = 1, rows = 1, numCameras = 1 } = this.config.cameraGrid || {};

    cameraGrid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
    cameraGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

    const totalCells = columns * rows;
    for (let i = 0; i < totalCells; i++) {
      if (i >= this.config.cameras.length || i >= numCameras) break;

      const camera = this.config.cameras[i];
      if (!camera) continue;

      const element = document.createElement('video');
      element.classList.add('camera-feed');
      element.setAttribute('data-placeholder', 
          `${camera.name || `Camera ${i + 1}`}\n${camera.url ? 'Loading...' : 'No feed configured'}`);

      if (camera.url) {
        element.setAttribute('autoplay', '');
        element.setAttribute('muted', '');
        element.setAttribute('playsinline', '');
        element.setAttribute('preload', 'auto');

        if (camera.url.startsWith('rtsp://')) {
          // RTSP stream
          try {
            const rtspConfig = {
              socket: 'wss://yourWebSocketProxyUrl', // Replace with your WebSocket proxy URL
              path: camera.url,
              bufferDuration: 60,
              videoBufferSize: 1024 * 1024 * 2,
              audioBufferSize: 1024 * 1024,
              useHardwareDecoder: true
            };
            const player = new Streamedian.WSPlayer(element, rtspConfig);
            element._player = player;
          } catch (error) {
            console.error(`Error initializing camera ${i + 1}:`, error);
            element.setAttribute('data-placeholder', 
                `${camera.name || `Camera ${i + 1}`}\nError initializing feed`);
          }
        } else if (Hls.isSupported() && camera.url.endsWith('.m3u8')) {
          // HLS stream
          const hls = new Hls({
            debug: false,
            enableWorker: true,
            lowLatencyMode: true,
            backBufferLength: 30,
            maxBufferLength: 30,
            maxMaxBufferLength: 30,
            maxBufferSize: 10 * 1000 * 1000,
            maxBufferHole: 0.5,
            liveSyncDurationCount: 2,
            liveMaxLatencyDurationCount: 5,
            progressive: false,
            manifestLoadingTimeOut: 10000,
            manifestLoadingMaxRetry: 2,
            enableWebVTT: false,
            enableCEA708Captions: false,
            stretchShortVideoTrack: false,
            capLevelToPlayerSize: true,
            startLevel: -1
          });

          if (element._hls) {
            element._hls.destroy();
          }

          element._hls = hls;

          try {
            hls.loadSource(camera.url);
            hls.attachMedia(element);

            hls.on(Hls.Events.MEDIA_ATTACHED, () => {
              console.log(`Camera ${i + 1} media attached`);
              element.play()
                .then(() => console.log(`Camera ${i + 1} playback started`))
                .catch(err => console.warn(`Camera ${i + 1} autoplay failed:`, err));
            });

            hls.on(Hls.Events.ERROR, (event, data) => {
              if (data.fatal) {
                console.error(`Camera ${i + 1} fatal error:`, data);
                hls.destroy();
                element.setAttribute('data-placeholder', 
                    `${camera.name || `Camera ${i + 1}`}\nError loading feed`);

                const retryDelay = Math.min(60000 * Math.pow(2, element._retryCount || 0), 300000);
                element._retryCount = (element._retryCount || 0) + 1;

                setTimeout(() => {
                  this.applyCameraSettings(i);
                }, retryDelay);
              }
            });
          } catch (error) {
            console.error(`Error initializing camera ${i + 1}:`, error);
            element.setAttribute('data-placeholder', 
                `${camera.name || `Camera ${i + 1}`}\nError initializing feed`);
          }
        } else if (element.canPlayType('application/vnd.apple.mpegurl')) {
          // Native HLS support
          element.src = camera.url;
          element.play();
        } else {
          console.warn('This browser does not support HLS');
        }
      }

      cameraGrid.appendChild(element);
    }
  }

  applyCameraSettings(index) {
    if (!this.config.cameras || !this.config.cameras[index]) return;
    
    const camera = this.config.cameras[index];
    console.log(`Applying settings for camera ${index + 1}:`, camera);

    this.setupCameras();
  }

  applySensorSettings(sensorId) {
    const sensorUrlInput = document.getElementById(`${sensorId}Url`);
    const sensorNameInput = document.getElementById(`${sensorId}Name`);
    const sensorIntervalInput = document.getElementById(`${sensorId}Interval`);

    if (sensorUrlInput && sensorNameInput && sensorIntervalInput) {
      const sensor = this.config.sensors[sensorId] || {};

      sensor.url = sensorUrlInput.value.trim();
      sensor.name = sensorNameInput.value.trim();
      sensor.refreshInterval = parseInt(sensorIntervalInput.value) || 30;

      this.config.sensors[sensorId] = sensor;

      // Ensure widget is enabled
      if (this.config.widgets[sensorId]) {
        this.config.widgets[sensorId].enabled = true;
        this.updateWidgetVisibility(sensorId, true);
      }

      // Update the sensor name in the widget
      const widget = document.getElementById(sensorId);
      if (widget) {
        widget.querySelector('.sensor-name').textContent = sensor.name;
      }

      // Start polling the sensor
      this.startSensorPolling(sensorId);
    }
  }

  setupEventListeners() {
    const settingsToggle = document.querySelector('.settings-toggle');
    const settingsPanel = document.querySelector('.settings-panel');

    settingsToggle.addEventListener('click', () => {
      settingsPanel.classList.toggle('active');
    });

    const themeSelect = document.getElementById('themeSelect');
    if (themeSelect) {
      themeSelect.value = this.config.theme;
      
      themeSelect.addEventListener('change', (e) => {
        this.config.theme = e.target.value;
        document.body.setAttribute('data-theme', e.target.value);
        this.applyConfig();
      });
    }

    const numCamerasInput = document.getElementById('numCameras');
    if (numCamerasInput) {
      numCamerasInput.value = this.config.cameraGrid.numCameras || 1;
      numCamerasInput.addEventListener('change', (e) => {
        const value = parseInt(e.target.value);
        if (!isNaN(value)) {
          this.config.cameraGrid.numCameras = value;
          this.setupCameraGrid(value);
        }
      });
    }

    const widgetOpacity = document.getElementById('widgetOpacity');
    const blurAmount = document.getElementById('blurAmount');
    const fontSize = document.getElementById('fontSize');

    if (widgetOpacity) {
      widgetOpacity.value = this.config.appearance.opacity;
      widgetOpacity.addEventListener('input', (e) => {
        this.config.appearance.opacity = parseFloat(e.target.value);
        this.updateAppearance();
      });
    }

    if (blurAmount) {
      blurAmount.value = this.config.appearance.blur;
      blurAmount.addEventListener('input', (e) => {
        this.config.appearance.blur = parseInt(e.target.value);
        this.updateAppearance();
      });
    }

    if (fontSize) {
      fontSize.value = this.config.appearance.fontSize;
      fontSize.addEventListener('input', (e) => {
        this.config.appearance.fontSize = parseInt(e.target.value);
        this.updateAppearance();
      });
    }

    document.querySelectorAll('.widget-toggle').forEach(toggle => {
      const toggleInput = toggle.querySelector('input');
      const widgetName = toggle.querySelector('span').textContent.trim();

      const widgetMap = {
        'Clock Widget': 'clock',
        'Weather Widget': 'weather',
        'Temperature Sensor 1': 'temp1',
        'Temperature Sensor 2': 'temp2'
      };

      const widgetId = widgetMap[widgetName];

      if (widgetId && this.config.widgets[widgetId]) {
        toggleInput.checked = this.config.widgets[widgetId].enabled;
        this.updateWidgetVisibility(widgetId, toggleInput.checked);

        toggleInput.addEventListener('change', (e) => {
          this.updateWidgetVisibility(widgetId, e.target.checked);
        });
      }
    });

    interact('.widget')
      .draggable({
        inertia: true,
        modifiers: [],
        listeners: {
          move: this._throttle(dragMoveListener, 16)
        }
      })
      .resizable({
        edges: { left: true, right: true, bottom: true, top: true },
        modifiers: [],
        listeners: {
          move: this._throttle((event) => {
            const target = event.target;
            const left = event.rect.left;
            const top = event.rect.top;

            target.style.width = `${event.rect.width}px`;
            target.style.height = `${event.rect.height}px`;
            target.style.left = `${left}px`;
            target.style.top = `${top}px`;

            // Adjust font size based on widget size
            const baseWidth = 250;
            const baseHeight = 150;
            const baseFontSize = 16;

            const scaleWidth = event.rect.width / baseWidth;
            const scaleHeight = event.rect.height / baseHeight;
            const scale = Math.min(scaleWidth, scaleHeight);
            const newFontSize = baseFontSize * scale;

            target.style.fontSize = `${newFontSize}px`;

          }, 16)
        }
      });

    document.getElementById('importConfig').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const importedConfig = JSON.parse(event.target.result);
            this.config = Object.assign({}, this.config, importedConfig);
            this.applyConfig();
          } catch (error) {
            console.error('Error importing configuration:', error);
            alert('Error importing configuration file');
          }
        };
        reader.readAsText(file);
      }
    });

    this.updateAppearance();
  }

  updateAppearance() {
    document.documentElement.style.setProperty('--widget-opacity', this.config.appearance.opacity);
    document.documentElement.style.setProperty('--blur-amount', `${this.config.appearance.blur}px`);
    document.documentElement.style.setProperty('--base-font-size', `${this.config.appearance.fontSize}px`);
  }
}

let configManager;

document.addEventListener('DOMContentLoaded', () => {
  configManager = new ConfigManager();

  function updateClock() {
    const now = new Date();
    document.querySelector('.clock').textContent = 
      now.toLocaleTimeString('en-GB', { hour12: false });
    document.querySelector('.date').textContent = 
      now.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' });
  }

  setInterval(updateClock, 1000);
  updateClock();

  document.addEventListener('keydown', (e) => {
    if (e.key >= '1' && e.key <= '9') {
      window.location.href = `index.html?config=${e.key}`;
    }
  });
});
    </script>
</head>
<body>
<div class="camera-grid"></div>

<button class="settings-toggle">⚙️</button>

<div class="dashboard">
  <div id="clock" class="widget">
    <div class="widget-content">
      <div class="clock"></div>
      <div class="date"></div>
    </div>
  </div>

  <div id="weather" class="widget">
    <div class="widget-content weather-widget">
      <input type="text" id="cityInput" placeholder="Enter city name...">
      <ul class="city-suggestions"></ul>
      <div class="weather-info">
        <div class="weather-icon">❓</div>
        <div class="temperature">--°C</div>
        <div class="last-update">Last updated: --</div>
        <div class="weather-details">
          <div class="wind">Wind: -- km/h</div>
          <div class="gusts">Gusts: -- km/h</div>
          <div class="pressure">Pressure: -- hPa</div>
          <div class="humidity">Humidity: --%</div>
        </div>
        <div class="forecast">
          <div class="forecast-title">Next Days:</div>
          <div class="forecast-items"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="temp1" class="widget">
    <div class="widget-content">
      <div class="sensor-name">Sensor 1</div>
      <div class="temperature">--°C</div>
      <div class="humidity">--%</div>
    </div>
  </div>

  <div id="temp2" class="widget">
    <div class="widget-content">
      <div class="sensor-name">Sensor 2</div>
      <div class="temperature">--°C</div>
      <div class="humidity">--%</div>
    </div>
  </div>
</div>

<div class="settings-panel">
  <h2>Settings</h2>

  <div class="settings-section">
    <h3>Theme</h3>
    <div class="setting-item">
      <label for="themeSelect">Select Theme:</label>
      <select id="themeSelect">
        <option value="dark">Dark</option>
        <option value="cats">Cats</option>
        <option value="space">Space</option>
      </select>
    </div>
  </div>

  <div class="settings-section">
    <h3>Appearance</h3>
    <div class="setting-item">
      <label for="widgetOpacity">Widget Opacity:</label>
      <input type="range" id="widgetOpacity" min="0.1" max="1" step="0.1" value="0.9">
    </div>
    <div class="setting-item">
      <label for="blurAmount">Blur Effect:</label>
      <input type="range" id="blurAmount" min="0" max="20" value="10">
    </div>
    <div class="setting-item">
      <label for="fontSize">Font Size:</label>
      <input type="range" id="fontSize" min="12" max="24" value="16">
    </div>
  </div>

  <div class="settings-section">
    <h3>Camera Feeds</h3>
    <div class="setting-item">
      <label for="numCameras">Number of Cameras (1-18):</label>
      <input type="number" id="numCameras" min="1" max="18" value="1">
    </div>
    <div id="cameraSettings">
    </div>
  </div>

  <div class="settings-section">
    <h3>Sensor Configuration</h3>
    <div class="setting-item">
      <h4>Temperature Sensor 1</h4>
      <label>Data URL:</label>
      <input type="text" id="temp1Url" placeholder="http://example.com/sensor1.txt">
      <label>Name:</label>
      <input type="text" id="temp1Name" placeholder="Sensor Name">
      <label>Refresh Interval (seconds):</label>
      <input type="number" id="temp1Interval" min="1" value="30">
      <button class="apply-button" onclick="configManager.applySensorSettings('temp1')">Apply</button>
    </div>
    <div class="setting-item">
      <h4>Temperature Sensor 2</h4>
      <label>Data URL:</label>
      <input type="text" id="temp2Url" placeholder="http://example.com/sensor2.txt">
      <label>Name:</label>
      <input type="text" id="temp2Name" placeholder="Sensor Name">
      <label>Refresh Interval (seconds):</label>
      <input type="number" id="temp2Interval" min="1" value="30">
      <button class="apply-button" onclick="configManager.applySensorSettings('temp2')">Apply</button>
    </div>
  </div>

  <div class="settings-section">
    <h3>Load Default Configuration</h3>
    <div class="setting-item">
      <div class="config-buttons">
        <button class="config-button" onclick="loadConfig(1)">Config 1</button>
        <button class="config-button" onclick="loadConfig(2)">Config 2</button>
        <button class="config-button" onclick="loadConfig(3)">Config 3</button>
        <button class="config-button" onclick="loadConfig(4)">Config 4</button>
        <button class="config-button" onclick="loadConfig(5)">Config 5</button>
        <button class="config-button" onclick="loadConfig(6)">Config 6</button>
        <button class="config-button" onclick="loadConfig(7)">Config 7</button>
        <button class="config-button" onclick="loadConfig(8)">Config 8</button>
        <button class="config-button" onclick="loadConfig(9)">Config 9</button>
      </div>
    </div>
  </div>

  <div class="settings-section">
    <h3>Widgets</h3>
    <div class="widget-toggles">
      <div class="widget-toggle">
        <span>Clock Widget</span>
        <label class="toggle-switch">
          <input type="checkbox" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="widget-toggle">
        <span>Weather Widget</span>
        <label class="toggle-switch">
          <input type="checkbox" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="widget-toggle">
        <span>Temperature Sensor 1</span>
        <label class="toggle-switch">
          <input type="checkbox" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="widget-toggle">
        <span>Temperature Sensor 2</span>
        <label class="toggle-switch">
          <input type="checkbox" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
    </div>
  </div>

  <div class="settings-section">
    <h3>Configuration</h3>
    <button class="button" onclick="configManager.exportConfig()">Export Configuration</button>
    <button class="button" onclick="document.getElementById('importConfig').click()">Import Configuration</button>
    <input type="file" id="importConfig" style="display: none" accept=".json">
    <button class="button" onclick="configManager.resetConfig()">Reset to Defaults</button>
  </div>
</div>
</body>
</html>